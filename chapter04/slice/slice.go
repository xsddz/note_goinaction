package slice

import (
	"fmt"
)

// Run 切片测试入口
func Run() {
	fmt.Printf("================================================================================\n")

	/*
		1. 切片是一个很小的对象，对底层数组进行了抽象，并提供相关的操作方法。切片有 3 个字段的
		数据结构，分别是指向底层数组的指针、切片访问的元素的个数（即长度）和切片允许增长到的元素
		个数（即容量）。
		2. 不允许创建容量小于长度的切片。
		3. 如果在 [] 运算符里指定了一个值，那么创建的就是数组而不是切片。只有不指定值的时候，才会创建切片。
		4. 对底层数组容量是 k 的切片 slice[i:j]来说
			- 长度: j - i
			- 容量: k - i
			对底层数组容量是 k 的切片 slice[i:j:n]来说
			- 长度: j - i
			- 容量: n - i
		5. 切片间的赋值操作，使得切片共享同一个底层数组。如果一个切片修改了该底层数组的共享部分，
		另一个切片也能感知到。
		6. 与切片的容量相关联的元素只能用于增长切片。在使用这部分元素前，必须将其合并到切片的长度里。
		7. 如果在创建切片时设置切片的容量和长度一样，就可以强制让新切片的第一个 append 操作创建新的
		底层数组，与原有的底层数组分离。新切片与原有的底层数组分离后，可以安全地进行后续修改，
		8. 关键字 range 配合关键字 for 来迭代切片里的元素时，range 创建了每个元素的副本，
		而不是直接返回对该元素的引用。关键字 range 总是会从切片头部开始迭代。
		9. 对于切片，函数 len 返回切片的长度，函数 cap 返回切片的容量。
	*/

	// 创建一个整型切片，其长度和容量都是 5 个元素
	s01 := make([]int, 5)
	fmt.Printf("s01:\t%T\t%v\n", s01, s01)

	// 创建一个整型切片，其长度为 3 个元素，容量为 5 个元素
	s02 := make([]int, 3, 5)
	fmt.Printf("s02:\t%T\t%v\n", s02, s02)

	// 创建字符串切片，其长度和容量都是 5 个元素
	s03 := []string{"Red", "Blue", "Green", "Yellow", "Pink"}
	fmt.Printf("s03:\t%T\t%v\n", s03, s03)

	// 创建一个整型切片，其长度和容量都是 3 个元素
	s04 := []int{10, 20, 30}
	// 改变索引为 1 的元素的值
	s04[1] = 25
	fmt.Printf("s04:\t%T\t%v\n", s04, s04)

	// 创建字符串切片，使用空字符串初始化第 100 个元素
	s05 := []string{99: ""}
	fmt.Printf("s05:\t%T\t%v\n", s05, s05)

	// 创建有 3 个元素的整型数组
	arr := [3]int{10, 20, 30}
	fmt.Printf("arr:\t%T\t%v\n", arr, arr)
	// 创建长度和容量都是 3 的整型切片
	s06 := []int{10, 20, 30}
	fmt.Printf("s06:\t%T\t%v\n", s06, s06)

	// 在声明时不做任何初始化，创建 nil 整型切片
	var s07 []int
	fmt.Printf("s07:\t%T\t%v\n", s07, s07)

	// 使用 make 创建空的整型切片
	s08 := make([]int, 0)
	// 使用切片字面量创建空的整型切片
	s09 := []int{}
	fmt.Printf("s08:\t%T\t%v\n", s08, s08)
	fmt.Printf("s09:\t%T\t%v\n", s09, s09)

	fmt.Printf("================================================================================\n")

	// 创建一个整型切片，其长度和容量都是 5 个元素
	s10 := []int{10, 20, 30, 40, 50}
	fmt.Printf("s10:\t%T\t%v\n", s10, s10)

	// 创建一个新切片，其长度是 2 个元素，容量是 4 个元素
	s11 := s10[1:3]
	fmt.Printf("s11:\t%T\t%v\n", s11, s11)

	// 修改 s11 索引为 1 的元素，同时也修改了原来的 s10 的索引为 2 的元素
	s11[1] = 35
	fmt.Printf("\nmodify index 1 value of s11:\n")
	fmt.Printf("s10:\t%T\t%v\n", s10, s10)
	fmt.Printf("s11:\t%T\t%v\n", s11, s11)

	// 使用原有的容量来分配一个新元素，将新元素赋值为 60
	s11 = append(s11, 60)
	s11 = append(s11, 70)
	s11 = append(s11, 80)
	s11 = append(s11, 90)
	fmt.Printf("\nappend value to s11:\n")
	fmt.Printf("s10:\t%T\t%v\n", s10, s10)
	fmt.Printf("s11:\t%T\t%v\n", s11, s11)

	fmt.Printf("================================================================================\n")

	// 创建字符串切片，其长度和容量都是 5 个元素
	s12 := []string{"Apple", "Orange", "Plum", "Banana", "Grape"}
	fmt.Printf("s10:\t%T\t%v\n", s12, s12)

	// 对第三个元素做切片，并用第三个索引选项限制容量，其长度和容量都是 1 个元素
	s13 := s12[2:3:3]
	fmt.Printf("s11:\t%T\t%v\n", s13, s13)

	// 向 slice 追加新字符串
	s13 = append(s13, "Kiwi")
	fmt.Printf("\nappend value to s13:\n")
	fmt.Printf("s10:\t%T\t%v\n", s12, s12)
	fmt.Printf("s11:\t%T\t%v\n", s13, s13)

	fmt.Printf("================================================================================\n")
}
